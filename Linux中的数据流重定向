### 数据流重定向
	- 在之前的操作中，常会看到>或>>操作，它们分别是将标准输出导入到一个文件或追加到一个文件中。这其实就是重定向，将原本输出到标准输出的数据重定向到一个文件中，因为标准输出(/dev/stdout)本身也是一个文件，我们将命令输出导向另一个文件，自然也是没有任何问题的。
	- 一、数据流重定向
		- 简单的回顾一下经常用到的两个重定向操作：
			echo "hello curry" > redirect
			echo "hello cdl" > redirect
			cat redirect
		- 当然前面没有用到的<和<<也是没有问题的，它们的区别在于重定向的方向不一致而已，>表示从左到右，<表示从右到左
		- 1. 简单的重定向
			- Linux默认提供了三个特殊的设备，用于终端的显示和输出，分别为stdin(标准输入,对应于在终端下的输入)，stdout(标准输出，对应于终端的输出)，stderr(标准错误输出，对应于终端的输出)
			
			- 文件描述符：文件描述符在形式上是一个非负数。实际上，它是一个索引值，指向内核为每个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是，文件描述符这个概念往往只适合用于UNIX、Linux这样的操作系统。
			- 将cat的连续输出(heredoc方式，输入EOF结束)重定向到一个文件
			``` shell
				mkdir documents
				cat > documents/test.c << EOF
				#include <stdio.h>
				int main()
				{
					printf("hello world\n");
					return 0;						
				}
				EOF
			```
			- 将一个文件作为命令的输入，标准输出作为命令的输出
				cat documents/test.c
			- 将echo命令通过管道穿过来的数据作为cat命令的输入，将标准输出作为命令的输出
				echo "hi" | cat
			- 将echo命令的输出从默认的标准输出重定向到一个普通文件
				echo "hello curry" > redirect
				cat redirect
		- 2. 标准错误重定向
			- 重定向标准输出到文件，这是一个很使用的操作，另一个很实用的操作是将标准错误重定向，标准输出和标准错误都被指向伪终端的屏幕显示，所以我们经常看到的一个命令的输出通常是同时包含了标准输出和标准错误的结果的。如下面的操作：
				- 使用cat操作命令同时读取两个文件，其中一个存在(test.c之前已经创建过了，另一个不存在)
					cat documents/test.c hello.c
				- 可以看到除了正确输出了前一个文件的内容，还在末尾出现了一条错误信息，下面将输出重定向到一个文件，这里将再也看不到任何输出了
					cat documents/test.c hello.c > somefile
				- 将标准错误重定向到标准输出，再将标准输出重定向到文件，注意要将重定向文件写在前面
					cat documents/test.c hello.c > somefile 2>&1
				- 或者只使用bash提供的特殊的重定向符号&将标准错误和标准输出同时重定向到文件
					cat documents/test.c hello.c &>somefilehell
				- 注意：应该在输出重定向文件描述符前加上&,否则shell会当做重定向到一个文件名为1的文件中
		- 3. 使用tee命令同时重定向到多个文件
			- 经常可能还有这样的操作，除了需要将输出重定向到文件之外，也需要将信息打印在终端，那么可以使用tee命令来实现：
				echo "hello world" | tee hello
				cat hello
		- 4. 永久重定向
			- 前面的重定向操作都是临时性的，即只对当前命令有效，那如何做到"永久"呢？比如在一个脚本中，你需要某一部分的命令的输出全部进行重定向，难道要让在每个命令上面加上临时重定向的操作吗？当然不需要，可以使用exec命令就可以实现"永久"重定向。exec命令的作用是使用指定的命令替换当前的shell，及使用一个进程替换当前进程，或者指定新的重定向：
				bash    先开启一个子shell
				exec 1>somefile  使用exec替换当前进程的重定向，将标准输出重定向到一个文件
			- 后面执行的命令的输出都被重定向到文件中，直接退出当前子shell，或取消exec的重定向
				ls
				exit
				cat somfile
		- 5. 创建输出文件描述符
			- 默认在shell中可以有9个打开的文件描述符，上面使用了也是它默认提供的0,1,2号文件描述符，另外还可以使用3-8的文件描述符，只是它们默认没有打开而已，可以使用下面命令查看当前shell进程中打开的文件描述符：
				cd /dev/fd/;ls -Al
			- 同样，使用exec命令可以创建新的文件描述符
				bash
				exec 3>somfile
			- 先进入目录，再查看，否则你可能不能得到正确的结果，然后再回到上一次的目录
				cd /dev/fd/;ls -Al;cd -
				echo "this is test" > &3
				cat somfile
				exit
		- 6.关闭文件描述符
			- 如上面我们打开的3还文件描述符，可以使用如下操作将它关闭
				exec 3>&-
				cd /dev/fd/;ls -Al;cd -
		- 7.完全屏蔽命令的输出
			- 在Linux中有一个被称为"黑洞"的设备文件，所以导入它的数据都将被吞噬。在类UNIX系统中，/dev/null，或称空设备，是一个特殊的设备文件，它通常被用于丢弃不需要的输出流，或作为用于输入流的空文件，这些操作通常由重定向完成。读取它则会立即得到一个EOF。
			- 可以利用这个/dev/null屏蔽命令的输出，这样的操作你将得不到任何输出结果：
				cat documents/test.c nefile 1>/dev/null 2>&1
		- 8. 使用xargs分割参数列表
			- xargs是一条UNIX和类UNIX操作系统的常用命令。它的作用是将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题。这个命令在有些时候是十分有用，特别是当用来处理产生大量输出结果的命令如find locate和grep的结果，详细用法请参看man手册文档。
			- 将/etc/passwd文件按:分割取第一个字段排序后，使用echo命令生成一个列表：
				cut -d : -f1 < /etc/passwd | sort | xargs echo
			
